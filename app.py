import streamlit as st #web app k liye
from langchain_community.document_loaders import TextLoader, PyPDFLoader, CSVLoader # text , pdf ,csv handler
from langchain.text_splitter import CharacterTextSplitter # text to chunk conversion
from langchain_groq import ChatGroq #groq integration
from langchain_core.prompts import ChatPromptTemplate   # structured prompts create aur response dene k liye
from langchain_core.output_parsers import StrOutputParser # LLM response to strings
from dotenv import load_dotenv #environment variables k liye
from fpdf import FPDF   #pdf create krne k liye
import time
import plotly.graph_objs as go
import plotly.express as px
import re
import math
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
import os
from groq import Groq
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication


# Explicitly load the Groq API key from Hugging Face secrets
os.environ['GROQ_API_KEY'] = os.getenv('GROQ_API_KEY')

# Now initialize the Groq client
client = Groq(api_key=os.environ.get('GROQ_API_KEY'))
load_dotenv()

# Initialize session state variables
if "default_model" not in st.session_state:
    st.session_state["default_model"] = "gemma2-9b-it" # default LLM model create kro if not already in session
if "messages" not in st.session_state:
    st.session_state["messages"] = [] # empty, to store messages chat
if "final_summary" not in st.session_state:
    st.session_state["final_summary"] = "" # doc summary
if "risk_assessment" not in st.session_state:
    st.session_state["risk_assessment"] = "" # risk assesment
if "chunks" not in st.session_state:
    st.session_state["chunks"] = [] #chunks
if "risk_score" not in st.session_state:
    st.session_state["risk_score"] = 0 # risk score
if "risk_categories" not in st.session_state:
    st.session_state["risk_categories"] = {} # risk categories   

tab1, tab2, tab3 = st.tabs(["Summary", "QnA ChatBot","Risk Assessment"])

def clean_markdown_for_pdf(text):
    # Remove heading markers
    text = re.sub(r'#+\s+', '', text)
    # Remove bullet points/asterisks
    text = re.sub(r'^\s*\*\s+', 'â€¢ ', text, flags=re.MULTILINE)
    # Remove other Markdown formatting characters
    text = re.sub(r'[_*]', '', text)
    return text

def send_pdf_email(recipient_email, pdf_data, document_name="document"):
    try:
        # Load environment variables
        load_dotenv()
        
        # Get email credentials from environment variables
        smtp_username = os.getenv('EMAIL_USERNAME')
        smtp_password = os.getenv('EMAIL_PASSWORD')
        smtp_server = os.getenv('EMAIL_SERVER', 'smtp.gmail.com')
        smtp_port = int(os.getenv('EMAIL_PORT', 587))
        sender_email = os.getenv('SENDER_EMAIL', smtp_username)
        
        if not smtp_username or not smtp_password:
            return False, "Email credentials not configured. Please check server configuration."
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = recipient_email
        msg['Subject'] = f"Legal Document Risk Assessment: {document_name}"
        
        # Email body
        body = f"""
        Dear User,
        
        Attached is your requested risk assessment report for the document: {document_name}.
        
        This report was generated by the Legal Document Analyzer application.
        
        Please note that this is an automated analysis and should not replace professional legal advice.
        
        Regards,
        Legal Document Analyzer Team
        """
        msg.attach(MIMEText(body, 'plain'))
        
        # Attach PDF
        pdf_attachment = MIMEApplication(pdf_data, _subtype='pdf')
        pdf_attachment.add_header('Content-Disposition', 'attachment', filename=f"{document_name}_risk_assessment.pdf")
        msg.attach(pdf_attachment)
        
        # Hugging Face Spaces usually allows port 587 for SMTP
        # Setup SMTP server with TLS
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_username, smtp_password)
        
        # Send email
        server.send_message(msg)
        server.quit()
        
        return True, "Email sent successfully!"
    
    except Exception as e:
        return False, f"Error sending email: {str(e)}"

with tab1:
    st.title("Experiment Legal Document Analyzer")
    st.divider()

    st.markdown("## Summarize and assess risks in your legal documents")

    # Upload File
    uploaded_file = st.file_uploader("Choose a file", type=["pdf", "txt", "csv"])

    llm = ChatGroq(model="gemma2-9b-it") #model
    parser = StrOutputParser()
    prompt_template = ChatPromptTemplate.from_template("Summarize the Following Document {document}")
    chain = prompt_template | llm | parser  #prompt llm aur parser combine ya unki chain

    if uploaded_file is not None:
        with st.spinner("Processing..."):
            try:
                print("File: ", uploaded_file)
                print("File type: ", uploaded_file.type)
                
                temp_file_path = uploaded_file.name
                print("File path: ", temp_file_path)
                
                # Save uploaded file
                with open(temp_file_path, "wb") as f:
                    f.write(uploaded_file.getbuffer())  

                # Create document loader
                if uploaded_file.type == "text/plain":
                    loader = TextLoader(temp_file_path)
                elif uploaded_file.type == "text/csv":
                    loader = CSVLoader(temp_file_path)
                elif uploaded_file.type == "application/pdf":
                    loader = PyPDFLoader(temp_file_path)
                else:
                    st.error("File type is not supported!")
                    st.stop()
                    
                # Create the document    
                doc = loader.load()
                print(doc)
                
                # Text Splitter - make chunks smaller to avoid token limits
                text_splitter = CharacterTextSplitter(chunk_size=800, chunk_overlap=100) #800 character and 100 character overlap
                
                #overlap is basically continuation of previous word, no overlap means ki pichla word pichle chunk m hoga next chunk will start fresh
                
                
                # Split the document into chunks
                st.session_state["chunks"] = text_splitter.split_documents(doc)
                print(f"Number of chunks: {len(st.session_state['chunks'])}")
            
            except Exception as e:
                print(e)
                st.error(f"Error processing file: {e}")
        st.success("File Uploaded")

    # Summary of Document
    if st.button("Summarize"):
        if "chunks" in st.session_state and st.session_state["chunks"]:
            summary_container = st.empty()
            chunk_summaries = []
            
            with st.spinner("Analyzing document chunks..."):
                progress_bar = st.progress(0)
                total_chunks = len(st.session_state["chunks"])
                
                try:
                    for i, chunk in enumerate(st.session_state["chunks"]):
                        # Summary prompt
                        chunk_prompt = ChatPromptTemplate.from_template(
                            "You are a highly skilled legal expert tasked with summarizing legal text. "
                            "Please summarize the following chunk of legal text in a concise manner, "
                            "highlighting the most critical information. Focus on key clauses, obligations, "
                            "rights, and definitions. Do not omit any key details:\n\n{document}"
                        )
                        
                        # Chain for summary
                        chunk_chain = chunk_prompt | llm | parser
                        chunk_summary = chunk_chain.invoke({"document": chunk.page_content})
                        chunk_summaries.append(chunk_summary)
                        
                        # Update progress
                        progress_bar.progress((i + 1) / total_chunks)
                        
                        # Add a small delay to avoid rate limiting
                        time.sleep(0.5)
                        
                except Exception as e:
                    print("Error analyzing chunks", e)
                    st.error(f"Error analyzing chunks: {e}")
                    st.stop()
                    
            # Final summary
            with st.spinner("Creating final summary..."):
                try:
                    # Process summaries in batches to stay within token limits
                    batch_size = 5  # Adjust based on your content size
                    batched_summaries = []
                    
                    for i in range(0, len(chunk_summaries), batch_size): 
                        batch = chunk_summaries[i:i+batch_size]
                        combined_batch = "\n\n".join(batch)
                        
                        # Create intermediate summary prompt
                        intermediate_summary_prompt = ChatPromptTemplate.from_template(
                            "You are a senior legal expert tasked with creating a concise summary from these "
                            "document summaries. Combine these summaries into a cohesive and "
                            "comprehensive summary:\n\n{document}"
                        )
                        
                        # Generate intermediate summary
                        intermediate_summary_chain = intermediate_summary_prompt | llm | parser
                        intermediate_summary = intermediate_summary_chain.invoke({"document": combined_batch})
                        batched_summaries.append(intermediate_summary)
                        
                        # Add a small delay to avoid rate limiting
                        time.sleep(1)
                    
                    # Final combination of batched summaries
                    combined_batched_summaries = "\n\n".join(batched_summaries)
                    
                    # Create final summary prompt
                    final_summary_prompt = ChatPromptTemplate.from_template(
                        "You are a senior legal expert tasked with creating a final summary from summarized chunks "
                        "of a legal document. Combine the key points from the provided summaries into a cohesive and "
                        "comprehensive summary. The final summary should be organized by key sections (e.g., Parties, "
                        "Definitions, Obligations, Rights, Term & Termination, etc.) and be detailed enough to capture "
                        "the main legal implications:\n\n{document}"
                    )
                    
                    # Generate final summary
                    final_summary_chain = final_summary_prompt | llm | parser
                    final_summary = final_summary_chain.invoke({"document": combined_batched_summaries})
                    
                    # Store results in session state
                    st.session_state["final_summary"] = final_summary
                    
                    # Display results
                    st.subheader("Document Summary")
                    st.write(final_summary)
                    
                    
                    
                    def create_summary_pdf(summary_content):
                        pdf = FPDF()
                        
                        # Add summary page
                        pdf.add_page()
                        pdf.set_font("Arial", "B", 16)
                        pdf.cell(0, 10, "Legal Document Summary", ln=True, align="C")
                        pdf.ln(10)
                        
                        cleaned_content = clean_markdown_for_pdf(summary_content)
                        
                        pdf.set_font("Arial", size=12)
                        lines = cleaned_content.split('\n')
                        for line in lines:
                            # Replace any non-latin1 characters
                            safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                            pdf.multi_cell(0, 10, txt=safe_line)
                        
                        return pdf.output(dest="S").encode("latin-1")
                    
                    # Download summary report
                    summary_pdf_data = create_summary_pdf(final_summary)
                    st.download_button(
                        label="Download Summary",
                        data=summary_pdf_data,
                        file_name="legal_document_summary.pdf",
                        mime="application/pdf"
                    )
                except Exception as e:
                    print("Error creating final summary", e)
                    st.error(f"Error creating final summary: {e}")
        else:
            st.error("Please upload a file first!")

with tab2:
    # heading
    st.title("Legal Document QnA")
    st.write("Ask questions about your legal document and its risks")
    st.divider()

    # Display chat messages
    for message in st.session_state["messages"]:
        with st.chat_message(message["role"]):
            st.write(message["content"])

    # User input
    user_question = st.chat_input("Ask a question about your legal document:")
    
    if user_question:
        # Add user message to chat history
        st.session_state["messages"].append({"role": "user", "content": user_question})
        
        # Display user message
        with st.chat_message("user"):
            st.write(user_question)
            
        # Generate response
        with st.chat_message("assistant"):
            with st.spinner("Analyzing..."):
                if st.session_state["final_summary"] and st.session_state["risk_assessment"]:
                    # Combine summary and risk assessment as context
                    context = f"DOCUMENT SUMMARY:\n{st.session_state['final_summary']}\n\nRISK ASSESSMENT:\n{st.session_state['risk_assessment']}"
                    
                    # Create prompt with context
                    chat_prompt = ChatPromptTemplate.from_template(
                        "You are a legal assistant answering questions about a legal document. "
                        "Use the following summary and risk assessment as context to answer the question "
                        "with a cautious, precise legal perspective.\n\n"
                        "CONTEXT: {context}\n\n"
                        "QUESTION: {question}\n\n"
                        "If the answer isn't clearly in the context, acknowledge that limitation and provide "
                        "general legal information with appropriate disclaimers. Avoid making definitive "
                        "legal conclusions without sufficient information."
                    )
                    chat_chain = chat_prompt | llm | parser
                    response = chat_chain.invoke({
                        "context": context,
                        "question": user_question
                    })
                else:
                    response = "Please analyze a legal document in the Summary tab and generate a risk assessment in the Risk Assessment tab first."
                
                st.write(response)
                
        # Add assistant response to chat history
        st.session_state["messages"].append({"role": "assistant", "content": response})


# Function to calculate risk score
def calculate_risk_score(risk_assessment):
    risk_categories = {
        "Low Risk": 0,
        "Medium Risk": 0,
        "High Risk": 0
    }
    
    # GDPR-specific risk patterns
    gdpr_risk_patterns = [
        # High-severity GDPR violations
        (r'\b(Severe\s+GDPR\s+Violation|Critical\s+Compliance\s+Issue)\b', 'High Risk', 10),
        (r'\b(Significant\s+Data\s+Protection\s+Risk)\b', 'High Risk', 8),
        
        # Medium-severity GDPR risks
        (r'\b(Potential\s+GDPR\s+Violation|Compliance\s+Gap)\b', 'Medium Risk', 5),
        (r'\b(Limited\s+Data\s+Protection\s+Risk)\b', 'Medium Risk', 4),
        
        # Low-severity GDPR observations
        (r'\b(Minor\s+GDPR\s+Concern|Improvement\s+Needed)\b', 'Low Risk', 2)
    ]
    
    # GDPR-specific keyword scoring
    gdpr_keywords = {
        'consent': 4,
        'personal data': 3,
        'data breach': 6,
        'cross-border transfer': 5,
        'processing conditions': 4,
        'data subject rights': 4,
        'anonymization': 2,
        'pseudonymization': 2,
        'data minimization': 3,
        'purpose limitation': 3,
        'storage limitation': 3,
        'data protection impact assessment': 5,
        'controller': 2,
        'processor': 2,
        'non-compliant': 5,
        'unauthorized processing': 7,
        'inadequate security': 6
    }
    
    total_risk_score = 0
    risk_match_count = 0
    
    # Check for explicit GDPR risk patterns
    for pattern, category, weight in gdpr_risk_patterns:
        risks = re.findall(pattern, risk_assessment, re.IGNORECASE)
        count = len(risks)
        risk_categories[category] += count
        total_risk_score += count * weight
        risk_match_count += count
    
    # Keyword-based risk assessment
    keyword_score = 0
    for keyword, score in gdpr_keywords.items():
        keyword_count = risk_assessment.lower().count(keyword)
        if keyword_count > 0:
            keyword_score += keyword_count * score
            
            # Categorize risks based on keyword severity
            if score <= 3:
                risk_categories['Low Risk'] += keyword_count
            elif score <= 5:
                risk_categories['Medium Risk'] += keyword_count
            else:
                risk_categories['High Risk'] += keyword_count
    
    # Combine pattern and keyword scores
    total_risk_score += keyword_score
    
    # GDPR-specific risk normalization
    if total_risk_score > 0:
        # Use a more conservative scaling for GDPR compliance
        normalized_score = min(max(15 * math.log(total_risk_score + 1), 0), 100)
    else:
        normalized_score = 0
    
    return int(normalized_score), risk_categories


def generate_rag_risk_assessment(chunks):
    try:
        # Create embeddings
        embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2",
            model_kwargs={'device': 'cpu'},
            encode_kwargs={'normalize_embeddings': True}
        )

        # Create vector store
        texts = [chunk.page_content for chunk in chunks]
        metadatas = [chunk.metadata for chunk in chunks]
        vectorstore = FAISS.from_texts(texts, embeddings, metadatas=metadatas)

        # Retrieve relevant chunks based on context
        retriever = vectorstore.as_retriever(search_kwargs={"k": 3})

        # Modify risk assessment prompt to use retrieved context
        risk_prompt = ChatPromptTemplate.from_template(
            "You are a GDPR compliance expert. Analyze the following legal text for potential GDPR violations "
            "and risks. Use the retrieved context to provide a comprehensive assessment:\n\n"
            "RETRIEVED CONTEXT:\n{context}\n\n"
            "Analyze the text against key GDPR principles:\n"
            "1. Lawfulness, Fairness, and Transparency\n"
            "2. Purpose Limitation\n"
            "3. Data Minimization\n"
            "4. Accuracy\n"
            "5. Storage Limitation\n"
            "6. Integrity and Confidentiality\n"
            "7. Accountability\n\n"
            "Provide a detailed risk assessment focusing on:\n"
            "- Specific GDPR Article/Principle Potentially Violated\n"
            "- Description of the Risk\n"
            "- Potential Compliance Gaps\n"
            "- Severity of the Risk (Low/Medium/High)\n"
            "- Recommended Mitigation Strategies"
        )

        # Use Groq LLM
        llm = ChatGroq(model="mixtral-8x7b-32768")
        parser = StrOutputParser()

        # Create RAG chain
        rag_chain = risk_prompt | llm | parser

        # Retrieve relevant chunks and generate risk assessment
        retrieved_docs = retriever.get_relevant_documents("GDPR compliance risks")
        retrieved_context = "\n---\n".join([doc.page_content for doc in retrieved_docs])

        risk_assessment = rag_chain.invoke({
            "context": retrieved_context
        })

        return risk_assessment

    except Exception as e:
        st.error(f"RAG Risk Assessment Error: {e}")
        return None

with tab3:
    # Risk Assessment tab
    st.title("Legal Document Risk Assessment")
    st.write("Generate a detailed risk assessment for your legal document")
    st.divider()
    
    # Check if document has been uploaded
    if "chunks" not in st.session_state or not st.session_state["chunks"]:
        st.warning("Please upload a document in the Summary tab first.")
    else:
        # Risk Assessment Generation
        if st.button("Generate Risk Assessment"):
            with st.spinner("Analyzing risks in document chunks..."):
                try:
                    # Use RAG for risk assessment
                    final_risk_assessment = generate_rag_risk_assessment(
                    st.session_state["chunks"]
                    )
                    chunk_risks = []
                    
                    # Display progress
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    total_chunks = len(st.session_state["chunks"])
                    
                    for i, chunk in enumerate(st.session_state["chunks"]):
                        status_text.text(f"Processing chunk {i+1} of {total_chunks}")
                        
                        # Risk assessment prompt
                        risk_prompt = ChatPromptTemplate.from_template(
                            "You are a GDPR compliance expert. Analyze the following legal text for potential GDPR violations "
                            "and risks. Evaluate the document against key GDPR principles:\n\n"
                            "1. Lawfulness, Fairness, and Transparency\n"
                            "2. Purpose Limitation\n"
                            "3. Data Minimization\n"
                            "4. Accuracy\n"
                            "5. Storage Limitation\n"
                            "6. Integrity and Confidentiality\n"
                            "7. Accountability\n\n"
                            "For each identified GDPR risk, specify:\n"
                            "- Specific GDPR Article/Principle Potentially Violated\n"
                            "- Description of the Risk\n"
                            "- Potential Compliance Gaps\n"
                            "- Severity of the Risk (Low/Medium/High)\n"
                            "- Recommended Mitigation Strategies\n\n"
                            "Focus on:\n"
                            "- Personal data processing conditions\n"
                            "- Data subject rights\n"
                            "- Consent mechanisms\n"
                            "- Data protection principles\n"
                            "- Cross-border data transfers\n"
                            "- Security and breach notification requirements\n\n"
                            "TEXT TO ANALYZE:\n{document}"
                        )
                        
                        # Chain for risk assessment
                        risk_chain = risk_prompt | llm | parser
                        chunk_risk = risk_chain.invoke({"document": chunk.page_content})
                        chunk_risks.append(chunk_risk)
                        
                        # Update progress
                        progress_bar.progress((i + 1) / total_chunks)
                        
                        # Add a delay to avoid rate limiting
                        time.sleep(1)
                        
                except Exception as e:
                    print("Error analyzing risks", e)
                    st.error(f"Error analyzing risks: {e}")
                    st.stop()
                    
                # Create final risk assessment
                with st.spinner("Creating final risk assessment..."):
                    try:
                        # Process risks in batches to stay within token limits
                        batch_size = 3  # Use a smaller batch size for risk assessments
                        batched_risks = []
                        
                        status_text.text("Processing risk batches...")
                        batch_progress = st.progress(0)
                        num_batches = (len(chunk_risks) + batch_size - 1) // batch_size
                        
                        for i in range(0, len(chunk_risks), batch_size):
                            batch = chunk_risks[i:i+batch_size]
                            combined_batch = "\n---\n".join(batch)
                            
                            # Create intermediate risk assessment prompt
                            intermediate_risk_prompt = ChatPromptTemplate.from_template(
                                "You are a legal risk assessment expert tasked with creating a concise risk report "
                                "from individual risk assessments. Combine these risk assessments, eliminate duplicates, "
                                "and prioritize by severity:\n\n{document}"
                            )
                            
                            # Generate intermediate risk assessment
                            intermediate_risk_chain = intermediate_risk_prompt | llm | parser
                            intermediate_risk = intermediate_risk_chain.invoke({"document": combined_batch})
                            batched_risks.append(intermediate_risk)
                            
                            # Update batch progress
                            batch_progress.progress((i + batch_size) / len(chunk_risks))
                            
                            # Add a delay to avoid rate limiting
                            time.sleep(1.5)
                        
                        # Process batched risks in smaller groups if there are many
                        if len(batched_risks) > 2:
                            status_text.text("Combining intermediate risk assessments...")
                            secondary_batched_risks = []
                            secondary_batch_size = 2
                            
                            for i in range(0, len(batched_risks), secondary_batch_size):
                                batch = batched_risks[i:i+secondary_batch_size]
                                combined_batch = "\n\n".join(batch)
                                
                                # Create secondary intermediate risk prompt
                                secondary_risk_prompt = ChatPromptTemplate.from_template(
                                    "You are a legal risk assessment expert. Combine these risk assessments "
                                    "into a single cohesive report, eliminating duplicates and organizing by category:\n\n{document}"
                                )
                                
                                # Generate secondary intermediate risk assessment
                                secondary_risk_chain = secondary_risk_prompt | llm | parser
                                secondary_risk = secondary_risk_chain.invoke({"document": combined_batch})
                                secondary_batched_risks.append(secondary_risk)
                                
                                # Add a delay to avoid rate limiting
                                time.sleep(1.5)
                            
                            combined_risks = "\n\n".join(secondary_batched_risks)
                        else:
                            # Combine batched risks directly if there are few enough
                            combined_risks = "\n\n".join(batched_risks)
                        
                        status_text.text("Creating final risk assessment report...")
                        
                        # Create final risk assessment prompt
                        final_risk_prompt = ChatPromptTemplate.from_template(
                            "You are a legal risk assessment expert tasked with creating a comprehensive risk report "
                            "from risk assessments of document chunks. Create a consolidated risk report "
                            "that categorizes and prioritizes the identified risks. Focus on:\n"
                            "1. Group related risks by category (e.g., Compliance, Liability, Ambiguity)\n"
                            "2. Prioritize risks by severity\n"
                            "3. Provide specific mitigation recommendations\n\n"
                            "Format the report with clear sections, bullet points for individual risks, and "
                            "a summary risk profile (Low, Medium, or High) for the overall document.\n\n"
                            "INPUT RISK ASSESSMENTS:\n{document}"
                        )
                        
                        # Generate final risk assessment
                        final_risk_chain = final_risk_prompt | llm | parser
                        final_risk_assessment = final_risk_chain.invoke({"document": combined_risks})
                        
                        # Store results in session state
                        st.session_state["risk_assessment"] = final_risk_assessment
                        
                        # Hide progress indicators
                        status_text.empty()
                        
                        # Display results
                        st.subheader("Risk Assessment")
                        st.write(final_risk_assessment)
    
                        # Calculate risk score and categories
                        risk_score, risk_categories = calculate_risk_score(final_risk_assessment)
                        st.session_state["risk_score"] = risk_score
                        st.session_state["risk_categories"] = risk_categories
                        
                        # Visualizations
                        st.subheader("Risk Visualization")
                        
                        # Risk Score Gauge
                        fig_gauge = go.Figure(go.Indicator(
                            mode = "gauge+number",
                            value = risk_score,
                            domain = {'x': [0, 1], 'y': [0, 1]},
                            title = {'text': "Overall Risk Score"},
                            gauge = {
                                'axis': {'range': [0, 100]},
                                'bar': {'color': "darkred"},
                                'steps' : [
                                    {'range': [0, 30], 'color': "green"},
                                    {'range': [30, 70], 'color': "yellow"},
                                    {'range': [70, 100], 'color': "red"}
                                ],
                            }
                        ))
                        st.plotly_chart(fig_gauge, use_container_width=True)
                        
                        # Risk Category Pie Chart
                        risk_data = list(risk_categories.values())
                        risk_labels = list(risk_categories.keys())
                        
                        fig_pie = go.Figure(data=[go.Pie(
                            labels=risk_labels, 
                            values=risk_data, 
                            hole=.3,
                            marker_colors=['green', 'yellow', 'red']
                        )])
                        fig_pie.update_layout(title_text='Risk Distribution')
                        st.plotly_chart(fig_pie, use_container_width=True)
                        
                        # Bar Chart for Risk Categories
                        fig_bar = go.Figure(data=[go.Bar(
                            x=risk_labels, 
                            y=risk_data,
                            marker_color=['green', 'yellow', 'red']
                        )])
                        fig_bar.update_layout(
                            title_text='Number of Risks by Category',
                            xaxis_title='Risk Level',
                            yaxis_title='Number of Risks'
                        )
                        st.plotly_chart(fig_bar, use_container_width=True)
    
                        # Create PDF function for risk assessment
                        def create_risk_pdf(risk_content):
                            pdf = FPDF()
                            
                            # Add risk assessment page
                            pdf.add_page()
                            pdf.set_font("Arial", "B", 16)
                            pdf.cell(0, 10, "Risk Assessment Report", ln=True, align="C")
                            pdf.ln(10)

                            cleaned_content = clean_markdown_for_pdf(risk_content)
                            
                            pdf.set_font("Arial", size=12)
                            risk_lines = cleaned_content.split('\n')
                            for line in risk_lines:
                                # Replace any non-latin1 characters
                                safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                                pdf.multi_cell(0, 10, txt=safe_line)
                                
                            return pdf.output(dest="S").encode("latin-1")
                        
                        # Download risk assessment report
                        risk_pdf_data = create_risk_pdf(final_risk_assessment)
                        st.download_button(
                            label="Download Risk Assessment",
                            data=risk_pdf_data,
                            file_name="legal_document_risk_assessment.pdf",
                            mime="application/pdf"
                        )
                        
                        # Create combined PDF function
                        def create_combined_pdf(summary_content, risk_content):
                            pdf = FPDF()
                            
                            # Add summary page
                            pdf.add_page()
                            pdf.set_font("Arial", "B", 16)
                            pdf.cell(0, 10, "Legal Document Summary", ln=True, align="C")
                            pdf.ln(10)

                            cleaned_content = clean_markdown_for_pdf(summary_content)
                            
                            pdf.set_font("Arial", size=12)
                            summary_lines = cleaned_content.split('\n')
                            for line in summary_lines:
                                # Replace any non-latin1 characters
                                safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                                pdf.multi_cell(0, 10, txt=safe_line)
                            
                            # Add risk assessment page
                            pdf.add_page()
                            pdf.set_font("Arial", "B", 16)
                            pdf.cell(0, 10, "Risk Assessment Report", ln=True, align="C")
                            pdf.ln(10)
                            
                            pdf.set_font("Arial", size=12)
                            risk_lines = risk_content.split('\n')
                            for line in risk_lines:
                                # Replace any non-latin1 characters
                                safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                                pdf.multi_cell(0, 10, txt=safe_line)
                                
                            return pdf.output(dest="S").encode("latin-1")
                        
                        # Download combined report if summary exists
                        if st.session_state["final_summary"]:
                            combined_pdf_data = create_combined_pdf(st.session_state["final_summary"], final_risk_assessment)
                            st.download_button(
                                label="Download Complete Analysis",
                                data=combined_pdf_data,
                                file_name="legal_document_complete_analysis.pdf",
                                mime="application/pdf"
                            )
                        
                        # Add email section
                        st.divider()
                        st.subheader("Email the Risk Assessment")
                        
                        # Add form for email input
                        with st.form(key="email_form"):
                            email = st.text_input("Enter your email address")
                            document_name = st.text_input("Document name (optional)", value="Legal Document")
                            send_type = st.radio(
                                "What would you like to send?", 
                                ["Risk Assessment Only", "Complete Analysis (Summary + Risk Assessment)"]
                            )
                            submit_button = st.form_submit_button(label="Send Email")
                            
                            if submit_button:
                                if not email or "@" not in email or "." not in email:
                                    st.error("Please enter a valid email address.")
                                else:
                                    with st.spinner("Sending email..."):
                                        try:
                                            if send_type == "Complete Analysis (Summary + Risk Assessment)" and st.session_state["final_summary"]:
                                                pdf_data = create_combined_pdf(st.session_state["final_summary"], final_risk_assessment)
                                                filename = f"{document_name}_complete_analysis"
                                            else:
                                                pdf_data = create_risk_pdf(final_risk_assessment)
                                                filename = f"{document_name}_risk_assessment"
                                                
                                            success, message = send_pdf_email(email, pdf_data, document_name)
                                            
                                            if success:
                                                st.success(message)
                                            else:
                                                st.error(message)
                                        except Exception as e:
                                            st.error(f"Error sending email: {str(e)}")
                    except Exception as e:
                        print("Error creating final risk assessment", e)
                        st.error(f"Error creating final risk assessment: {e}")
        
        # Show existing risk assessment if available
        elif "risk_assessment" in st.session_state and st.session_state["risk_assessment"]:
            st.subheader("Risk Assessment")
            st.write(st.session_state["risk_assessment"])
            
            # Create PDF function for existing risk assessment
            def create_risk_pdf(risk_content):
                pdf = FPDF()
                
                # Add risk assessment page
                pdf.add_page()
                pdf.set_font("Arial", "B", 16)
                pdf.cell(0, 10, "Risk Assessment Report", ln=True, align="C")
                pdf.ln(10)

                cleaned_content = clean_markdown_for_pdf(risk_content)
                
                pdf.set_font("Arial", size=12)
                risk_lines = cleaned_content.split('\n')
                for line in risk_lines:
                    # Replace any non-latin1 characters
                    safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                    pdf.multi_cell(0, 10, txt=safe_line)
                    
                return pdf.output(dest="S").encode("latin-1")
            
            # Download button for existing risk assessment
            risk_pdf_data = create_risk_pdf(st.session_state["risk_assessment"])
            st.download_button(
                label="Download Risk Assessment",
                data=risk_pdf_data,
                file_name="legal_document_risk_assessment.pdf",
                mime="application/pdf"
            )
            
            # Combined PDF if summary exists
            if "final_summary" in st.session_state and st.session_state["final_summary"]:
                def create_combined_pdf(summary_content, risk_content):
                    pdf = FPDF()
                    
                    # Add summary page
                    pdf.add_page()
                    pdf.set_font("Arial", "B", 16)
                    pdf.cell(0, 10, "Legal Document Summary", ln=True, align="C")
                    pdf.ln(10)

                    cleaned_content = clean_markdown_for_pdf(summary_content)
                    
                    pdf.set_font("Arial", size=12)
                    summary_lines = cleaned_content.split('\n')
                    for line in summary_lines:
                        # Replace any non-latin1 characters
                        safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                        pdf.multi_cell(0, 10, txt=safe_line)
                    
                    # Add risk assessment page
                    pdf.add_page()
                    pdf.set_font("Arial", "B", 16)
                    pdf.cell(0, 10, "Risk Assessment Report", ln=True, align="C")
                    pdf.ln(10)
                    
                    pdf.set_font("Arial", size=12)
                    risk_lines = risk_content.split('\n')
                    for line in risk_lines:
                        # Replace any non-latin1 characters
                        safe_line = ''.join(c if ord(c) < 256 else ' ' for c in line)
                        pdf.multi_cell(0, 10, txt=safe_line)
                        
                    return pdf.output(dest="S").encode("latin-1")
                
                # Download combined report
                combined_pdf_data = create_combined_pdf(st.session_state["final_summary"], st.session_state["risk_assessment"])
                st.download_button(
                    label="Download Complete Analysis",
                    data=combined_pdf_data,
                    file_name="legal_document_complete_analysis.pdf",
                    mime="application/pdf"
                )
            
            # Add email section for existing risk assessment
            st.divider()
            st.subheader("Email the Risk Assessment")
            
            # Add form for email input
            with st.form(key="email_form_existing"):
                email = st.text_input("Enter your email address")
                document_name = st.text_input("Document name (optional)", value="Legal Document")
                send_type = st.radio(
                    "What would you like to send?", 
                    ["Risk Assessment Only", "Complete Analysis (Summary + Risk Assessment)"]
                )
                submit_button = st.form_submit_button(label="Send Email")
                
                if submit_button:
                    if not email or "@" not in email or "." not in email:
                        st.error("Please enter a valid email address.")
                    else:
                        with st.spinner("Sending email..."):
                            try:
                                if send_type == "Complete Analysis (Summary + Risk Assessment)" and "final_summary" in st.session_state and st.session_state["final_summary"]:
                                    pdf_data = create_combined_pdf(st.session_state["final_summary"], st.session_state["risk_assessment"])
                                    filename = f"{document_name}_complete_analysis"
                                else:
                                    pdf_data = create_risk_pdf(st.session_state["risk_assessment"])
                                    filename = f"{document_name}_risk_assessment"
                                    
                                success, message = send_pdf_email(email, pdf_data, document_name)
                                
                                if success:
                                    st.success(message)
                                else:
                                    st.error(message)
                            except Exception as e:
                                st.error(f"Error sending email: {str(e)}")
